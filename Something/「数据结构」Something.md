## 线性表

### 顺序表（顺序存储）

- 静态分配
- 动态分配

### 链表（链式存储）

- 单向链表

  ```js
  {
      value: "节点的值",
      next: "指向下一节点"
  }
  ```

- 双向链表

  ```js
  {
      value: "节点的值",
      prev: "指向上一节点",
      next: "指向下一节点"
  }
  ```

- 循环链表

  - 最后一个节点指回头节点
  - 循环单向链表
  - 循环双向链表

- 静态链表

  - 分配一整片连续的内存空间
  - 对象数组
  - `index=0`：头节点
  - `next=-1`：NULL

![](../_images/A628EC40-A335-423D-8459-74922F17432C-0251643.png)

## 操作受限的线性表

### 1. 栈

- 先进后出
- 栈顶进出
- 逻辑结构与普通线性表相同
- 顺序栈：顺序存储实现的栈
- 链栈：链式存储实现的栈

### 2. 队列

- 先进先出
- 队尾入，队头出

### 3. 双端队列

![image-20201007160844466](../_images/image-20201007160844466.png)

### 栈的应用

- 括号匹配
- 逆波兰式（后缀表达式）
- 调用栈

### 队列的应用

- 树的层次遍历（~~广度优先遍历~~）

## 串

- 子串：串中任意个**连续的**字符组成的子序列
- 子序列：序列的一部分项按原有次序排列而得的序列，**不要求连续**
- 串是一种特殊的线性表，串的数据元素之间也呈<u>线性关系</u>，但串的数据元素限定为<u>字符集</u>
- 模式匹配：在`主串`中找到与`模式串`相同的**子串**（未必存在）

## 树与二叉树

### 树

> 树是**n**个节点的有限集合（n≥0）
>
> n=0时，称为空树
>
> 任意非空树应满足：
>
> 1. 有且仅有一个特定的，**根结点**
> 2. 当n>1时，其余结点可以分为**m**个互不相交的有限集合（m>0），其中每一个集合本身又是一棵树，称为根节点的**子树**

- 树是一种**逻辑结构**
- 结点的**度**：树中一个结点的<u>孩子个数</u>
- 树的**度**：树中结点的最大**度**数
- 树的**高度**：树中结点的最大层数
- 结点的**高度**：从`叶结点`开始，自底向上，逐层累加
- 结点的**深度**：从`根节点`开始，自顶向下，逐层累加
- 有序树：树中结点的各子树，从左到右是**有次序**的，不能互换；反之为`无序树`
- 路径：两个结点之间的路径 => **结点序列**，自顶向下
- 森林：m棵互不相交的树的集合（m≥0）

### 二叉树

#### 1. 满二叉树

- 高度为 h，含有  2<sup>h</sup>-1 个结点的二叉树
- 所有的叶子结点一定在最后一层
- 编号：从上到下，从左至右

![image-20201110202632136](../_images/image-20201110202632136.png)

#### 2. 满二叉树

- 高度为 h，有 n 个结点的二叉树，其每个结点的编号都与高度为 h 的满二叉树中的编号相同
- 叶子结点只可能在最高的两层上出现
- 最高层的叶子结点，都依次排在最左边的位置

![image-20201110202657245](../_images/image-20201110202657245.png)

#### 3. 二叉排序树

- 若树非空，对任意结点若存在左子树/右子树，则其左子树上的**所有结点**的值均<u>小于</u>该节点，右子树上**所有结点**的值均<u>大于</u>该节点。
- 左子树/右子树也是一棵二叉排序树 *递归定义的结构*

![image-20201110203734370](../_images/image-20201110203734370.png)

#### 4. 平衡二叉树

- 二叉树上**任意节点**的左子树和右子树的深度之差不超过 1
- 左子树/右子树也是一棵平衡二叉树 *递归定义的结构*

### 二叉树的性质

1. n<sub>0</sub> = n<sub>2</sub> + 1
2. 非空二叉树上，第 k 层上之多有 2<sup>k-1</sup> 个结点（k≥1）

### 二叉树的顺序存储

- 数组下标对应，**补完后**的完全二叉树的「从上到下，从左到右」编号
- 对于结点`i`：左孩子编号`2i`，右孩子编号`2i+1`
- 添加不存在的空节点，数组中用`0`表示

![image-20201112163716539](../_images/image-20201112163716539.png)

|     index     |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :-----------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 数组（value） |      |  1   |  2   |  3   |  4   |  0   |  5   |

### 二叉树的链式存储

| leftChild | value | rightChild |
| :-------: | :---: | :--------: |
|  左孩子   |  值   |   右孩子   |

### 二叉树的遍历

- 先序遍历：根 左 右
- 中序遍历：左 根 右
- 后序遍历：左 右 根
- 层次遍历：使用`队列`

### 树的存储结构

#### 1. 双亲表示法

![image-20201112181424383](../_images/image-20201112181424383.png)

#### 2. 孩子表示法

![image-20201112181534886](../_images/image-20201112181534886.png)

#### 3. 孩子兄弟表示法

左孩子，右兄弟

![image-20201112181905953](../_images/image-20201112181905953.png) 

### 二叉树的应用

1. `平衡二叉树`的**插入**思路，用于降低`二叉排序树`的查找效率为 log<sub>2</sub>n
- 先插入，再调整
- 每次调整**最小**的不平衡子树
- LL平衡旋转（右单旋转）
- RR平衡旋转（左单旋转）
- LR平衡旋转（先左后右双旋转）
- RL平衡旋转（先右后左双旋转）

2. 哈弗曼树